<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Relatório Final: Condução Transiente 1D</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <!-- MathJax Configuration -->
    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                processEscapes: true
            },
            svg: { fontCache: 'global' }
        };
    </script>
    <script type="text/javascript" id="MathJax-script" async
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
    </script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&family=JetBrains+Mono:wght@400;500&display=swap');

        body { font-family: 'Inter', sans-serif; background-color: #f1f5f9; color: #1e293b; }
        .paper { max-width: 210mm; margin: 40px auto; background: white; padding: 20mm 25mm; box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1); border-radius: 4px; }
        
        h1 { font-size: 22pt; font-weight: 800; color: #0f172a; line-height: 1.2; margin-bottom: 10px; }
        h2 { font-size: 16pt; font-weight: 700; color: #1e293b; border-bottom: 2px solid #e2e8f0; padding-bottom: 8px; margin-top: 30px; margin-bottom: 15px; }
        h3 { font-size: 13pt; font-weight: 600; color: #334155; margin-top: 20px; margin-bottom: 10px; }
        h4 { font-size: 11pt; font-weight: 600; color: #475569; margin-top: 15px; margin-bottom: 5px; text-transform: uppercase; letter-spacing: 0.05em; }
        
        p { margin-bottom: 12px; line-height: 1.6; text-align: justify; font-size: 11pt; }
        ul { list-style-type: disc; margin-left: 20px; margin-bottom: 12px; font-size: 11pt; }
        
        .math-box { 
            background: #f8fafc; border: 1px solid #cbd5e1; border-radius: 6px; 
            padding: 15px; margin: 20px 0; overflow-x: auto; text-align: center; 
        }
        
        .code-block {
            font-family: 'JetBrains Mono', monospace; font-size: 9pt; 
            background: #1e293b; color: #f8fafc; padding: 15px; 
            border-radius: 6px; overflow-x: auto; margin: 15px 0;
            line-height: 1.4;
            white-space: pre; 
        }

        table { width: 100%; border-collapse: collapse; margin: 20px 0; font-size: 10pt; }
        th { background: #e2e8f0; color: #334155; font-weight: 700; padding: 10px; border: 1px solid #cbd5e1; }
        td { padding: 8px; border: 1px solid #cbd5e1; text-align: center; }
        tr:nth-child(even) { background: #f8fafc; }

        .chart-wrapper { position: relative; height: 400px; width: 100%; margin: 30px 0; border: 1px solid #e2e8f0; padding: 10px; border-radius: 6px; }

        .handwritten-img {
            width: 100%;
            max-width: 650px;
            margin: 20px auto;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            display: block;
        }
        .img-caption {
            text-align: center;
            font-size: 0.9rem;
            color: #64748b;
            margin-top: -10px;
            margin-bottom: 25px;
            font-style: italic;
        }
        
        .comparison-table td { text-align: left; vertical-align: top; }
        .var-code { font-family: 'JetBrains Mono', monospace; color: #dc2626; background: #fee2e2; padding: 2px 4px; border-radius: 4px; font-size: 0.9em; }

        /* Estilos do Painel de Entrada */
        .input-group { margin-bottom: 10px; }
        .input-group label { display: block; font-size: 0.85rem; font-weight: 600; color: #475569; margin-bottom: 4px; }
        .input-group input { 
            width: 100%; padding: 6px 10px; font-family: 'JetBrains Mono', monospace; font-size: 0.9rem;
            border: 1px solid #cbd5e1; border-radius: 4px; background: #f8fafc; color: #0f172a;
            transition: border-color 0.2s;
        }
        .input-group input:focus { outline: none; border-color: #2563eb; background: #fff; box-shadow: 0 0 0 2px rgba(37,99,235,0.1); }
        .btn-run {
            background-color: #2563eb; color: white; font-weight: 600; padding: 10px 20px;
            border-radius: 6px; border: none; cursor: pointer; transition: background 0.2s;
            display: inline-flex; align-items: center; gap: 8px; font-size: 0.95rem;
        }
        .btn-run:hover { background-color: #1d4ed8; }
        .btn-run:active { transform: translateY(1px); }

        @media print {
            @page { size: A4; margin: 20mm; }
            body { background-color: white !important; color: black !important; font-size: 12pt; -webkit-print-color-adjust: exact; }
            .paper { box-shadow: none !important; margin: 0 !important; padding: 0 !important; max-width: 100% !important; border: none !important; }
            .code-block { white-space: pre-wrap !important; word-wrap: break-word !important; background-color: #f3f4f6 !important; color: #000 !important; border: 1px solid #ccc !important; font-size: 8pt !important; }
            .chart-wrapper { height: 300px !important; border: 1px solid #ddd !important; break-inside: avoid; }
            .no-print { display: none !important; }
        }
    </style>
</head>
<body>

<div class="paper">
    
    <!-- Cabeçalho -->
    <div class="text-center mb-10">
        <p class="text-sm font-bold text-slate-500 uppercase tracking-widest mb-2">Universidade Federal do Paraná</p>
        <p class="text-xs text-slate-400 uppercase tracking-widest mb-4">Programa de Pós-Graduação em Métodos Numéricos em Engenharia</p>
        <h1>Solução Numérica da Difusão de Calor 1D Transiente</h1>
        <p class="text-slate-600 font-medium mt-2">Relatório do 1º Trabalho Computacional</p>
        <p class="text-slate-500 text-sm mt-1">Aluno: Romulo de Aguiar Beninca</p>
    </div>

    <!-- 1. Introdução -->
    <section>
        <h2>1. Definição do Problema</h2>
        <p>
            O presente trabalho tem como objetivo desenvolver uma solução numérica para o problema clássico de difusão de calor unidimensional em regime transiente. O cenário físico consiste em uma placa plana de espessura $L$.
        </p>
        <p>
            Conforme instrução do professor, para a modelagem matemática, partimos da equação diferencial parcial parabólica que governa o fenômeno, assumindo propriedades constantes e ausência de geração interna de calor, conforme estudamos no capítulo 4. Os detalhes do problema, incluindo a equação governante foram dados na Figura 1.
        </p>
        
        <img src="image_68b261.jpg" alt="Definição do Problema e Dados" class="handwritten-img">
        <p class="img-caption">Figura 1: Definição do problema, equação governante e parâmetros físicos.</p>

        <p>Em suma, buscamos resolver numericamente a equação:</p>
        <div class="math-box">$$ \frac{\partial T}{\partial t} = \alpha \frac{\partial^2 T}{\partial x^2} $$</div>
    </section>

    <!-- 2. Dedução -->
    <section>
        <h2>2. Dedução Numérica (Volumes Finitos)</h2>
        <h3>2.1. Discretização e Método $\theta$</h3>
        <p>
            Para a solução numérica, adotou-se o Método dos Volumes Finitos (MVF). O domínio espacial $[0, L]$ foi particionado em $N$ volumes de controle uniformes de largura $\Delta x$. A integração da equação governante foi realizada tanto no espaço quanto no tempo.
        </p>
        <img src="image_68afb9.jpg" alt="Discretização do Domínio" class="handwritten-img">
        <p class="img-caption">Figura 2: Processo de discretização do domínio e integração da equação.</p>

        <p>
            No que tange à discretização temporal, aplicou-se o <strong>Método $\theta$</strong>. Para este trabalho, optou-se especificamente pelo esquema de <strong>Crank-Nicolson</strong> ($\theta = 0.5$).
        </p>
        <img src="image_68af9c.jpg" alt="Aplicação do Método Theta" class="handwritten-img">
        <p class="img-caption">Figura 3: Desenvolvimento algébrico da equação discretizada para volumes internos.</p>

        <h3>2.2. Tratamento dos Contornos</h3>
        <p>
            Um ponto crucial nesta implementação é o tratamento das condições de contorno. A dedução completa para os volumes adjacentes aos contornos (esquerdo e direito) é apresentada na Figura 4.
        </p>
        <img src="image_68af94.jpg" alt="Dedução dos Contornos" class="handwritten-img">
        <p class="img-caption">Figura 4: Dedução dos coeficientes modificados para os volumes de contorno.</p>
    </section>

    <!-- 3. Correspondência Algébrica vs. Implementação -->
    <section>
        <h2>3. Da Teoria à Prática: Implementação Computacional</h2>
        <p>
            A implementação do código foi realizada utilizando a linguagem JavaScript. Para otimizar o cálculo, utilizamos variáveis auxiliares para agrupar os termos do passo de tempo anterior ($n$) que compõem o termo fonte. A tabela abaixo relaciona a matemática deduzida com as variáveis do código JavaScript apresentado na Seção 5:
        </p>
        <div class="overflow-x-auto">
            <table class="comparison-table">
                <thead>
                    <tr>
                        <th width="30%">Termo / Conceito</th>
                        <th width="35%">Expressão Algébrica (Dedução)</th>
                        <th width="35%">Variável no Código (JS)</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Termo Difusivo</strong><br>(Parte Implícita)</td>
                        <td>$$ \theta \frac{\Delta t}{\Delta x} $$</td>
                        <td><div class="var-code">termo_difusivo = theta * dt / dx</div></td>
                    </tr>
                    <tr>
                        <td><strong>Termo de Acúmulo</strong></td>
                        <td>$$ \frac{\Delta x}{\alpha} $$</td>
                        <td><div class="var-code">termo_acumulo = dx / alpha</div></td>
                    </tr>
                    <tr>
                        <td><strong>Coeficiente Central $a_P$</strong><br>(Contorno $i=1$)</td>
                        <td>$$ a_P = \frac{\Delta x}{\alpha} + 3 \theta \frac{\Delta t}{\Delta x} $$</td>
                        <td><div class="var-code">aP[0] = 3.0 * termo_difusivo + termo_acumulo</div></td>
                    </tr>
                    <tr>
                        <td><strong>Termo Fonte $b_P$</strong><br>(Contribuição Central Explícita)</td>
                        <td>$$ \frac{\Delta x}{\alpha} - 3(1-\theta)\frac{\Delta t}{\Delta x} $$</td>
                        <td>
                            <div class="var-code">difusivo_explicito = (1.0 - theta) * dt / dx</div>
                            <div class="var-code">b1_contorno = termo_acumulo - 3.0 * difusivo_explicito</div>
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>
    </section>

    <!-- 4. Resultados e Simulação Interativa -->
    <section>
        <h2>4. Análise dos Resultados e Simulação</h2>
        
        <!-- ÁREA INTERATIVA DE INPUTS -->
        <div class="bg-slate-50 border border-slate-200 rounded-lg p-6 mb-8 no-print">
            <h3 class="text-lg font-bold text-slate-700 border-b border-slate-200 pb-2 mb-4">Painel de Configuração da Simulação</h3>
            
            <div class="grid grid-cols-2 md:grid-cols-4 gap-4">
                <div class="input-group">
                    <label>N (Volumes)</label>
                    <input type="number" id="input_N" value="10" min="3" step="1">
                </div>
                <div class="input-group">
                    <label>M (Passos de Tempo)</label>
                    <input type="number" id="input_M" value="5" min="1" step="1">
                </div>
                <div class="input-group">
                    <label>tF (Tempo Final [s])</label>
                    <input type="number" id="input_tF" value="20.0" step="1.0">
                </div>
                <div class="input-group">
                    <label>Alpha (m²/s)</label>
                    <input type="text" id="input_alpha" value="1.17e-4">
                </div>
                <div class="input-group">
                    <label>L (Comprimento [m])</label>
                    <input type="number" id="input_L" value="0.1" step="0.01">
                </div>
                <div class="input-group">
                    <label>Theta (0=Ex, 0.5=CN, 1=Im)</label>
                    <input type="number" id="input_theta" value="0.5" min="0" max="1" step="0.1">
                </div>
                <div class="input-group">
                    <label>Ta (Esq. [°C])</label>
                    <input type="number" id="input_Ta" value="0.0" step="10">
                </div>
                <div class="input-group">
                    <label>Tb (Dir. [°C])</label>
                    <input type="number" id="input_Tb" value="0.0" step="10">
                </div>
            </div>

            <div class="mt-4 flex justify-end">
                <button class="btn-run" onclick="executarSimulacaoPeloUI()">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                        <path d="M10.804 8 5 4.633v6.734L10.804 8zm.792-.696a.802.802 0 0 1 0 1.392l-6.363 3.692C4.713 12.69 4 12.345 4 11.692V4.308c0-.653.713-.998 1.233-.696l6.363 3.692z"/>
                    </svg>
                    Atualizar Simulação
                </button>
            </div>
        </div>
        <!-- FIM ÁREA INTERATIVA -->

        <h3>4.1. Perfil de Temperatura ($t = t_F$)</h3>
        <p>A comparação entre a solução numérica e a analítica para o tempo final configurado.</p>
        <div class="chart-wrapper">
            <canvas id="profileChart"></canvas>
        </div>
        
        <h3>4.2. Histórico da Temperatura Média</h3>
        <p>Evolução da temperatura média da placa em escala logarítmica (eixo Y), demonstrando o decaimento exponencial.</p>
        <div class="chart-wrapper">
            <canvas id="historyChart"></canvas>
        </div>

        <h3>4.3. Tabela de Erros ($t = t_F$)</h3>
        <div class="overflow-x-auto mt-6">
            <table>
                <thead>
                    <tr>
                        <th>Vol</th>
                        <th>Posição $x$ (m)</th>
                        <th>$T_{analitica}$ (°C)</th>
                        <th>$T_{numerica}$ (°C)</th>
                        <th>Erro Absoluto</th>
                    </tr>
                </thead>
                <tbody id="tableBody"></tbody>
            </table>
        </div>
    </section>

    <!-- 5. Código Computacional -->
    <section>
        <h2>5. Implementação em JavaScript</h2>
        <p>Abaixo apresenta-se o núcleo do algoritmo numérico implementado, que roda no navegador para gerar os resultados acima.</p>
        <p>O código foi criado baseando-se no método TDMA para resolver sistemas tridiagonais, e usando com base o código em fortran disponibilizado pelo professor. Devido a natureza da web o arquivo de entrada foi adaptado e apresenado abaixo, similarmente a o arquivo utilizado em fortran como entrada.
        </p>
    <p>O código javascript esta organizado  da seguinte forma :
        <ul>
            <li>Funções Auxiliares: Funções matemáticas de apoio para cálculos analíticos e integração numérica.</li>
            <li>Solução TDMA: Implementação do algoritmo Tri-Diagonal Matrix Algorithm para resolver o sistema linear.</li>
            <li>Função de Interface: Função que lê os inputs da interface web e inicia a simulação.</li>
            <li>Simulação Principal: Função que executa a simulação, monta a matriz, resolve o sistema e coleta resultados.</li>
            <li>Geração de Arquivos: Funções para formatar e gerar os arquivos de entrada e saida.</li>
            <li>Renderização de Resultados: Funções para atualizar a tabela e gráficos na interface web.</li>
        </ul>
    </p>
        <div class="code-block">// --- SOLVER TDMA (Tri-Diagonal Matrix Algorithm) ---
function() {
    // Variáveis Globais de Gráfico para destruição correta
    let chartProfile = null;
    let chartHistory = null;

    // --- FUNÇÕES AUXILIARES ---
    const solucaoAnalitica = (pos, tempo, alpha, L) => 
        Math.exp(-alpha * Math.pow(Math.PI/L, 2) * tempo) * Math.sin(Math.PI*pos/L);

    const mediaAnalitica = (tempo, alpha, L) => 
        (2.0/Math.PI) * Math.exp(-alpha * Math.pow(Math.PI/L, 2) * tempo);

    function calcMediaTrapezoidal(arrT, dx, N, Ta, Tb, L) {
        let soma = 0.0;
        soma += 0.25 * (Ta + arrT[0]) * dx;
        for(let i=1; i < N; i++) {
            soma += 0.5 * (arrT[i-1] + arrT[i]) * dx;
        }
        soma += 0.25 * (arrT[N-1] + Tb) * dx;
        return soma / L;
    }

    function resolverTDMA(a, b, c, d) {
        let n = d.length;
        let cp = new Float64Array(n);
        let dp = new Float64Array(n);
        let solucao = new Float64Array(n);
        cp[0] = c[0] / a[0];
        dp[0] = d[0] / a[0];
        for (let i = 1; i < n; i++) {
            let m = a[i] - b[i] * cp[i - 1];
            cp[i] = c[i] / m;
            dp[i] = (d[i] + b[i] * dp[i - 1]) / m;
        }
        solucao[n - 1] = dp[n - 1];
        for (let i = n - 2; i >= 0; i--) {
            solucao[i] = cp[i] * solucao[i + 1] + dp[i];
        }
        return solucao;
    }

    // --- FUNÇÃO DE INTERFACE (Lê Inputs e Chama Simulação) ---
    // Tornar esta função globalmente acessível para o botão onClick
    window.executarSimulacaoPeloUI = function() {
        // Ler valores
        const N = parseInt(document.getElementById('input_N').value);
        const M = parseInt(document.getElementById('input_M').value);
        const tF = parseFloat(document.getElementById('input_tF').value);
        const alpha = parseFloat(document.getElementById('input_alpha').value);
        const L = parseFloat(document.getElementById('input_L').value);
        const theta = parseFloat(document.getElementById('input_theta').value);
        const Ta = parseFloat(document.getElementById('input_Ta').value);
        const Tb = parseFloat(document.getElementById('input_Tb').value);

        executarSimulacao(N, M, tF, alpha, L, theta, Ta, Tb);
    }

    // --- SIMULAÇÃO PRINCIPAL ---
    function executarSimulacao(N, M, tFinal, alpha, L, theta, Ta, Tb) {
        let dx = L/N;
        let dt = tFinal/M;
        
        // Arrays de Dados
        let T = new Float64Array(N);
        let To = new Float64Array(N); 
        let x = new Float64Array(N);
        
        let historicoTempo = [0];
        let historicoT_num = [];
        let historicoT_anal = [];
        
        // Dados para relatório
        let report_aW = new Float64Array(N);
        let report_aE = new Float64Array(N);
        let report_aP = new Float64Array(N);
        let report_b_primeiro_passo = new Float64Array(N);

        // Inicialização
        for(let i=0; i<N; i++) {
            x[i] = (i + 0.5) * dx;
            T[i] = Math.sin(Math.PI * x[i] / L);
            To[i] = T[i];
        }

        historicoT_num.push(calcMediaTrapezoidal(T, dx, N, Ta, Tb, L));
        historicoT_anal.push(mediaAnalitica(0, alpha, L));

        // Coeficientes Matriz A
        let aW = new Float64Array(N);
        let aP = new Float64Array(N);
        let aE = new Float64Array(N);
        let termo_difusivo = theta * dt / dx;
        let termo_acumulo = dx / alpha;

        // Montagem Matriz
        aW[0] = 0.0; aE[0] = termo_difusivo; aP[0] = 3.0 * termo_difusivo + termo_acumulo;
        for(let i=1; i<N-1; i++) { aW[i] = termo_difusivo; aE[i] = termo_difusivo; aP[i] = 2.0*termo_difusivo + termo_acumulo; }
        aW[N-1] = termo_difusivo; aE[N-1] = 0.0; aP[N-1] = 3.0 * termo_difusivo + termo_acumulo;

        // Salvar coefs
        for(let i=0; i<N; i++) { report_aW[i]=aW[i]; report_aP[i]=aP[i]; report_aE[i]=aE[i]; }

        // Loop Tempo
        let tempo = 0;
        for(let passo=0; passo < M; passo++) {
            tempo += dt;
            let b = new Float64Array(N);
            let difusivo_explicito = (1.0 - theta) * dt / dx;
            
            let b1_contorno = termo_acumulo - 3.0 * difusivo_explicito; 
            let b2 = difusivo_explicito;
            let b1_interno = termo_acumulo - 2.0 * difusivo_explicito;

            b[0] = b1_contorno*To[0] + b2*To[1] + 2.0*Ta*(dt/dx); 
            for(let i=1; i<N-1; i++) b[i] = b1_interno*To[i] + b2*(To[i-1] + To[i+1]);
            b[N-1] = b1_contorno*To[N-1] + b2*To[N-2] + 2.0*Tb*(dt/dx); 

            if (passo === 0) for(let k=0; k<N; k++) report_b_primeiro_passo[k] = b[k];

            T = resolverTDMA(aP, aW, aE, b);
            for(let i=0; i<N; i++) To[i] = T[i];

            historicoTempo.push(tempo);
            historicoT_num.push(calcMediaTrapezoidal(T, dx, N, Ta, Tb, L));
            historicoT_anal.push(mediaAnalitica(tempo, alpha, L));
        }

        renderizarTabela(N, x, T, tFinal, alpha, L);
        renderizarGraficos(N, x, T, tFinal, alpha, L, historicoTempo, historicoT_num, historicoT_anal);
        gerarArquivoSaida(N, M, tFinal, theta, alpha, L, Ta, Tb, report_aW, report_aP, report_aE, report_b_primeiro_passo, x, T, historicoTempo, historicoT_num, historicoT_anal);
        gerarArquivoEntrada(N, M, tFinal, theta, alpha, L, Ta, Tb);
    }

    function fmtE(num) {
        if (num === 0) return "0.000000000000000E+00";
        let s = num.toExponential(15); 
        let parts = s.split('e');
        let mantissa = parts[0];
        let exponent = parseInt(parts[1]);
        let sign = exponent >= 0 ? '+' : '-';
        let expVal = Math.abs(exponent).toString().padStart(2, '0');
        return mantissa + 'E' + sign + expVal;
    }

    function gerarArquivoEntrada(N, M, tFinal, theta, alpha, L, Ta, Tb) {
        let txt = `trabalho1 ...... arq:   nome do aquivo de saída de dados
    ${N}            N:     numero de volumes de controle
     ${M}            M:     numero de passos de tempo
   ${tFinal.toFixed(1)}d0         tf:    tempo final [s]
    ${theta}d0         theta: esquema (0.0=Expl, 0.5=CN, 1.0=Impl)
 ${alpha.toExponential(2).replace('e','d')}          alpha: difusividade termica [m2/s]
    ${L}d0         L:     comprimento do dominio [m]
    ${Ta.toFixed(1)}d0         Ta:    temperatura contorno esquerdo [C]
    ${Tb.toFixed(1)}d0         Tb:    temperatura contorno direito [C]
     1            freq:  frequencia de escrita dos resultados`;
        document.getElementById('output-arquivo-entrada').textContent = txt;
    }

    function gerarArquivoSaida(N, M, tFinal, theta, alpha, L, Ta, Tb, aW, aP, aE, b, x, T, hTempo, hNum, hAnal) {
        let txt = "Solução Numérica da Eq. de Difusão de Calor 1D em Regime Transiente com Propriedades Constantes\n\n";
        txt += "Dados de entrada\n\n";
        txt += `                ${N}  = N:      número de volumes de controle\n`;
        txt += `  ${fmtE(alpha)}  = alpha:  difusividade térmica [m2/s]\n`;
        txt += `  ${fmtE(L)}  = L:      comprimento do domínio [m]\n`;
        txt += `  ${fmtE(Ta)}  = Ta:     temperatura do contorno esquerdo (x=0) [°C]\n`;
        txt += `  ${fmtE(Tb)}  = Tb:     temperatura do contorno direito  (x=L) [°C]\n`;
        txt += `  ${fmtE(theta)}  = theta:  formulação temporal empregada\n\n\n`;

        txt += "Coeficientes e termos-fontes\nvol.     oeste                    central                  leste                    termo-fonte\n";
        for(let i=0; i<N; i++) {
            txt += `${(i+1).toString().padStart(5)}    ${fmtE(aW[i])}    ${fmtE(aP[i])}    ${fmtE(aE[i])}    ${fmtE(b[i])}\n`;
        }
        
        txt += "\n\nSoluções numéricas\n\n    Volume     Posição [m]        Temp. numérica [°C]      Temp. analítica [°C]     Erro numérico [°C]\n";
        txt += `         0     ${fmtE(0.0)}    ${fmtE(Ta)}    ${fmtE(Ta)}    ${fmtE(0.0)}\n`;
        for(let i=0; i<N; i++) {
            let anal = solucaoAnalitica(x[i], tFinal, alpha, L);
            let erro = Math.abs(anal - T[i]);
            txt += `${(i+1).toString().padStart(10)}     ${fmtE(x[i])}    ${fmtE(T[i])}    ${fmtE(anal)}    ${fmtE(erro)}\n`;
        }
        txt += `        ${N+1}     ${fmtE(L)}    ${fmtE(Tb)}    ${fmtE(Tb)}    ${fmtE(0.0)}\n`;

        txt += "\n\nSoluções numéricas - Temperaturas Médias\n\n    Tempo [s]                Numérica [°C]            Analítica [°C]           Erro numérico [°C]\n";
        for(let k=0; k<hTempo.length; k++) {
            let err = Math.abs(hNum[k] - hAnal[k]);
            txt += `    ${fmtE(hTempo[k])}    ${fmtE(hNum[k])}    ${fmtE(hAnal[k])}    ${fmtE(err)}\n`;
        }
        document.getElementById('output-arquivo-txt').textContent = txt;
    }

    function renderizarTabela(N, x, T, tFinal, alpha, L) {
        const tbody = document.getElementById('tableBody');
        let html = '';
        for(let i=0; i<N; i++) {
            let valAnal = solucaoAnalitica(x[i], tFinal, alpha, L);
            let valNum = T[i];
            let err = Math.abs(valAnal - valNum);
            html += `<tr><td>${i+1}</td><td>${x[i].toFixed(4)}</td><td style="color:#0284c7; font-weight:bold;">${valAnal.toFixed(6)}</td><td style="color:#059669; font-weight:bold;">${valNum.toFixed(6)}</td><td style="color:#dc2626;">${err.toExponential(4)}</td></tr>`;
        }
        tbody.innerHTML = html;
    }

    function renderizarGraficos(N, x, T, tFinal, alpha, L, hTempo, hNum, hAnal) {
        // PERFIL
        const ctxP = document.getElementById('profileChart').getContext('2d');
        if(chartProfile) chartProfile.destroy();
        
        let dataAnal = [];
        for(let i=0; i<=100; i++) { let pos = i*(L/100); dataAnal.push({x: pos, y: solucaoAnalitica(pos, tFinal, alpha, L)}); }
        
        chartProfile = new Chart(ctxP, {
            type: 'scatter',
            data: {
                datasets: [
                    { label: 'Numérica (VF)', data: Array.from(x).map((pos, i) => ({x: pos, y: T[i]})), backgroundColor: '#2563eb', pointRadius: 6 },
                    { label: 'Analítica', data: dataAnal, type: 'line', borderColor: '#dc2626', borderWidth: 2, pointRadius: 0, fill: false, tension: 0.4 }
                ]
            },
            options: { responsive: true, maintainAspectRatio: false, scales: { x: { type: 'linear', title: {display:true, text: 'Posição (m)'} }, y: { title: {display:true, text: 'Temperatura (°C)'}, min: 0 } } }
        });

        // HISTÓRICO
        const ctxH = document.getElementById('historyChart').getContext('2d');
        if(chartHistory) chartHistory.destroy();

        chartHistory = new Chart(ctxH, {
            type: 'line',
            data: {
                labels: hTempo,
                datasets: [
                    { label: 'Média Numérica', data: hNum, borderColor: '#2563eb', backgroundColor: '#2563eb', showLine: false, pointStyle: 'rectRot', pointRadius: 6 },
                    { label: 'Média Analítica', data: hAnal, borderColor: '#dc2626', borderWidth: 2, pointRadius: 0 }
                ]
            },
            options: { responsive: true, maintainAspectRatio: false, scales: { x: { title: {display:true, text: 'Tempo (s)'} }, y: { type: 'logarithmic', title: {display:true, text: 'Temp. Média (Log)'} } } }
        });
    }

    // Inicialização Automática
    executarSimulacaoPeloUI();
})();

// --- SIMULAÇÃO ---
// Esta função é chamada ao clicar em "Atualizar Simulação"
function executarSimulacao(N, M, tFinal, alpha, L, theta, Ta, Tb) {
    let dx = L/N;
    let dt = tFinal/M;
    // ... (Configuração de Coeficientes e Loop Temporal omitidos para brevidade) ...
}</div>
    </section>

    <!-- Apêndice: Arquivos de Entrada e Saída -->
    <section style="page-break-before: always;">
        <h2>Apêndice: Dados de Execução</h2>
        <p>Os dados abaixo são gerados dinamicamente com base nos parâmetros inseridos no painel de simulação.</p>

        <h3 class="text-sm font-bold uppercase text-slate-500 mb-2 mt-6">Arquivo de Entrada (Representação)</h3>
        <div id="output-arquivo-entrada" class="code-block"></div>

        <h3 class="text-sm font-bold uppercase text-slate-500 mb-2 mt-6">Arquivo de Saída Gerado (trabalho1.txt)</h3>
        <!-- Container onde o JS vai injetar o texto gerado -->
        <div id="output-arquivo-txt" class="code-block"></div>
    </section>

</div>

<!-- LÓGICA DO SISTEMA -->
<script>
(function() {
    // Variáveis Globais de Gráfico para destruição correta
    let chartProfile = null;
    let chartHistory = null;

    // --- FUNÇÕES AUXILIARES ---
    const solucaoAnalitica = (pos, tempo, alpha, L) => 
        Math.exp(-alpha * Math.pow(Math.PI/L, 2) * tempo) * Math.sin(Math.PI*pos/L);

    const mediaAnalitica = (tempo, alpha, L) => 
        (2.0/Math.PI) * Math.exp(-alpha * Math.pow(Math.PI/L, 2) * tempo);

    function calcMediaTrapezoidal(arrT, dx, N, Ta, Tb, L) {
        let soma = 0.0;
        soma += 0.25 * (Ta + arrT[0]) * dx;
        for(let i=1; i < N; i++) {
            soma += 0.5 * (arrT[i-1] + arrT[i]) * dx;
        }
        soma += 0.25 * (arrT[N-1] + Tb) * dx;
        return soma / L;
    }

    function resolverTDMA(a, b, c, d) {
        let n = d.length;
        let cp = new Float64Array(n);
        let dp = new Float64Array(n);
        let solucao = new Float64Array(n);
        cp[0] = c[0] / a[0];
        dp[0] = d[0] / a[0];
        for (let i = 1; i < n; i++) {
            let m = a[i] - b[i] * cp[i - 1];
            cp[i] = c[i] / m;
            dp[i] = (d[i] + b[i] * dp[i - 1]) / m;
        }
        solucao[n - 1] = dp[n - 1];
        for (let i = n - 2; i >= 0; i--) {
            solucao[i] = cp[i] * solucao[i + 1] + dp[i];
        }
        return solucao;
    }

    // --- FUNÇÃO DE INTERFACE (Lê Inputs e Chama Simulação) ---
    // Tornar esta função globalmente acessível para o botão onClick
    window.executarSimulacaoPeloUI = function() {
        // Ler valores
        const N = parseInt(document.getElementById('input_N').value);
        const M = parseInt(document.getElementById('input_M').value);
        const tF = parseFloat(document.getElementById('input_tF').value);
        const alpha = parseFloat(document.getElementById('input_alpha').value);
        const L = parseFloat(document.getElementById('input_L').value);
        const theta = parseFloat(document.getElementById('input_theta').value);
        const Ta = parseFloat(document.getElementById('input_Ta').value);
        const Tb = parseFloat(document.getElementById('input_Tb').value);

        executarSimulacao(N, M, tF, alpha, L, theta, Ta, Tb);
    }

    // --- SIMULAÇÃO PRINCIPAL ---
    function executarSimulacao(N, M, tFinal, alpha, L, theta, Ta, Tb) {
        let dx = L/N;
        let dt = tFinal/M;
        
        // Arrays de Dados
        let T = new Float64Array(N);
        let To = new Float64Array(N); 
        let x = new Float64Array(N);
        
        let historicoTempo = [0];
        let historicoT_num = [];
        let historicoT_anal = [];
        
        // Dados para relatório
        let report_aW = new Float64Array(N);
        let report_aE = new Float64Array(N);
        let report_aP = new Float64Array(N);
        let report_b_primeiro_passo = new Float64Array(N);

        // Inicialização
        for(let i=0; i<N; i++) {
            x[i] = (i + 0.5) * dx;
            T[i] = Math.sin(Math.PI * x[i] / L);
            To[i] = T[i];
        }

        historicoT_num.push(calcMediaTrapezoidal(T, dx, N, Ta, Tb, L));
        historicoT_anal.push(mediaAnalitica(0, alpha, L));

        // Coeficientes Matriz A
        let aW = new Float64Array(N);
        let aP = new Float64Array(N);
        let aE = new Float64Array(N);
        let termo_difusivo = theta * dt / dx;
        let termo_acumulo = dx / alpha;

        // Montagem Matriz
        aW[0] = 0.0; aE[0] = termo_difusivo; aP[0] = 3.0 * termo_difusivo + termo_acumulo;
        for(let i=1; i<N-1; i++) { aW[i] = termo_difusivo; aE[i] = termo_difusivo; aP[i] = 2.0*termo_difusivo + termo_acumulo; }
        aW[N-1] = termo_difusivo; aE[N-1] = 0.0; aP[N-1] = 3.0 * termo_difusivo + termo_acumulo;

        // Salvar coefs
        for(let i=0; i<N; i++) { report_aW[i]=aW[i]; report_aP[i]=aP[i]; report_aE[i]=aE[i]; }

        // Loop Tempo
        let tempo = 0;
        for(let passo=0; passo < M; passo++) {
            tempo += dt;
            let b = new Float64Array(N);
            let difusivo_explicito = (1.0 - theta) * dt / dx;
            
            let b1_contorno = termo_acumulo - 3.0 * difusivo_explicito; 
            let b2 = difusivo_explicito;
            let b1_interno = termo_acumulo - 2.0 * difusivo_explicito;

            b[0] = b1_contorno*To[0] + b2*To[1] + 2.0*Ta*(dt/dx); 
            for(let i=1; i<N-1; i++) b[i] = b1_interno*To[i] + b2*(To[i-1] + To[i+1]);
            b[N-1] = b1_contorno*To[N-1] + b2*To[N-2] + 2.0*Tb*(dt/dx); 

            if (passo === 0) for(let k=0; k<N; k++) report_b_primeiro_passo[k] = b[k];

            T = resolverTDMA(aP, aW, aE, b);
            for(let i=0; i<N; i++) To[i] = T[i];

            historicoTempo.push(tempo);
            historicoT_num.push(calcMediaTrapezoidal(T, dx, N, Ta, Tb, L));
            historicoT_anal.push(mediaAnalitica(tempo, alpha, L));
        }

        renderizarTabela(N, x, T, tFinal, alpha, L);
        renderizarGraficos(N, x, T, tFinal, alpha, L, historicoTempo, historicoT_num, historicoT_anal);
        gerarArquivoSaida(N, M, tFinal, theta, alpha, L, Ta, Tb, report_aW, report_aP, report_aE, report_b_primeiro_passo, x, T, historicoTempo, historicoT_num, historicoT_anal);
        gerarArquivoEntrada(N, M, tFinal, theta, alpha, L, Ta, Tb);
    }

    function fmtE(num) {
        if (num === 0) return "0.000000000000000E+00";
        let s = num.toExponential(15); 
        let parts = s.split('e');
        let mantissa = parts[0];
        let exponent = parseInt(parts[1]);
        let sign = exponent >= 0 ? '+' : '-';
        let expVal = Math.abs(exponent).toString().padStart(2, '0');
        return mantissa + 'E' + sign + expVal;
    }

    function gerarArquivoEntrada(N, M, tFinal, theta, alpha, L, Ta, Tb) {
        let txt = `trabalho1 ...... arq:   nome do aquivo de saída de dados
    ${N}            N:     numero de volumes de controle
     ${M}            M:     numero de passos de tempo
   ${tFinal.toFixed(1)}d0         tf:    tempo final [s]
    ${theta}d0         theta: esquema (0.0=Expl, 0.5=CN, 1.0=Impl)
 ${alpha.toExponential(2).replace('e','d')}          alpha: difusividade termica [m2/s]
    ${L}d0         L:     comprimento do dominio [m]
    ${Ta.toFixed(1)}d0         Ta:    temperatura contorno esquerdo [C]
    ${Tb.toFixed(1)}d0         Tb:    temperatura contorno direito [C]
     1            freq:  frequencia de escrita dos resultados`;
        document.getElementById('output-arquivo-entrada').textContent = txt;
    }

    function gerarArquivoSaida(N, M, tFinal, theta, alpha, L, Ta, Tb, aW, aP, aE, b, x, T, hTempo, hNum, hAnal) {
        let txt = "Solução Numérica da Eq. de Difusão de Calor 1D em Regime Transiente com Propriedades Constantes\n\n";
        txt += "Dados de entrada\n\n";
        txt += `                ${N}  = N:      número de volumes de controle\n`;
        txt += `  ${fmtE(alpha)}  = alpha:  difusividade térmica [m2/s]\n`;
        txt += `  ${fmtE(L)}  = L:      comprimento do domínio [m]\n`;
        txt += `  ${fmtE(Ta)}  = Ta:     temperatura do contorno esquerdo (x=0) [°C]\n`;
        txt += `  ${fmtE(Tb)}  = Tb:     temperatura do contorno direito  (x=L) [°C]\n`;
        txt += `  ${fmtE(theta)}  = theta:  formulação temporal empregada\n\n\n`;

        txt += "Coeficientes e termos-fontes\nvol.     oeste                    central                  leste                    termo-fonte\n";
        for(let i=0; i<N; i++) {
            txt += `${(i+1).toString().padStart(5)}    ${fmtE(aW[i])}    ${fmtE(aP[i])}    ${fmtE(aE[i])}    ${fmtE(b[i])}\n`;
        }
        
        txt += "\n\nSoluções numéricas\n\n    Volume     Posição [m]        Temp. numérica [°C]      Temp. analítica [°C]     Erro numérico [°C]\n";
        txt += `         0     ${fmtE(0.0)}    ${fmtE(Ta)}    ${fmtE(Ta)}    ${fmtE(0.0)}\n`;
        for(let i=0; i<N; i++) {
            let anal = solucaoAnalitica(x[i], tFinal, alpha, L);
            let erro = Math.abs(anal - T[i]);
            txt += `${(i+1).toString().padStart(10)}     ${fmtE(x[i])}    ${fmtE(T[i])}    ${fmtE(anal)}    ${fmtE(erro)}\n`;
        }
        txt += `        ${N+1}     ${fmtE(L)}    ${fmtE(Tb)}    ${fmtE(Tb)}    ${fmtE(0.0)}\n`;

        txt += "\n\nSoluções numéricas - Temperaturas Médias\n\n    Tempo [s]                Numérica [°C]            Analítica [°C]           Erro numérico [°C]\n";
        for(let k=0; k<hTempo.length; k++) {
            let err = Math.abs(hNum[k] - hAnal[k]);
            txt += `    ${fmtE(hTempo[k])}    ${fmtE(hNum[k])}    ${fmtE(hAnal[k])}    ${fmtE(err)}\n`;
        }
        document.getElementById('output-arquivo-txt').textContent = txt;
    }

    function renderizarTabela(N, x, T, tFinal, alpha, L) {
        const tbody = document.getElementById('tableBody');
        let html = '';
        for(let i=0; i<N; i++) {
            let valAnal = solucaoAnalitica(x[i], tFinal, alpha, L);
            let valNum = T[i];
            let err = Math.abs(valAnal - valNum);
            html += `<tr><td>${i+1}</td><td>${x[i].toFixed(4)}</td><td style="color:#0284c7; font-weight:bold;">${valAnal.toFixed(6)}</td><td style="color:#059669; font-weight:bold;">${valNum.toFixed(6)}</td><td style="color:#dc2626;">${err.toExponential(4)}</td></tr>`;
        }
        tbody.innerHTML = html;
    }

    function renderizarGraficos(N, x, T, tFinal, alpha, L, hTempo, hNum, hAnal) {
        // PERFIL
        const ctxP = document.getElementById('profileChart').getContext('2d');
        if(chartProfile) chartProfile.destroy();
        
        let dataAnal = [];
        for(let i=0; i<=100; i++) { let pos = i*(L/100); dataAnal.push({x: pos, y: solucaoAnalitica(pos, tFinal, alpha, L)}); }
        
        chartProfile = new Chart(ctxP, {
            type: 'scatter',
            data: {
                datasets: [
                    { label: 'Numérica (VF)', data: Array.from(x).map((pos, i) => ({x: pos, y: T[i]})), backgroundColor: '#2563eb', pointRadius: 6 },
                    { label: 'Analítica', data: dataAnal, type: 'line', borderColor: '#dc2626', borderWidth: 2, pointRadius: 0, fill: false, tension: 0.4 }
                ]
            },
            options: { responsive: true, maintainAspectRatio: false, scales: { x: { type: 'linear', title: {display:true, text: 'Posição (m)'} }, y: { title: {display:true, text: 'Temperatura (°C)'}, min: 0 } } }
        });

        // HISTÓRICO
        const ctxH = document.getElementById('historyChart').getContext('2d');
        if(chartHistory) chartHistory.destroy();

        chartHistory = new Chart(ctxH, {
            type: 'line',
            data: {
                labels: hTempo,
                datasets: [
                    { label: 'Média Numérica', data: hNum, borderColor: '#2563eb', backgroundColor: '#2563eb', showLine: false, pointStyle: 'rectRot', pointRadius: 6 },
                    { label: 'Média Analítica', data: hAnal, borderColor: '#dc2626', borderWidth: 2, pointRadius: 0 }
                ]
            },
            options: { responsive: true, maintainAspectRatio: false, scales: { x: { title: {display:true, text: 'Tempo (s)'} }, y: { type: 'logarithmic', title: {display:true, text: 'Temp. Média (Log)'} } } }
        });
    }

    // Inicialização Automática
    executarSimulacaoPeloUI();
})();
</script>

</body>
</html>